# Unlogg Docs
URL: /index

A collection of open source libraries and tools for building modern web applications.

import { Atom, Paintbrush } from "lucide-react";

<Cards>
  <Card icon={<Paintbrush />} href="/docs/unlogg-ui" title="Unlogg UI">
    A collection of UI components for building modern web applications.
  </Card>

  <Card icon={<Atom />} href="/docs/unlogg-hooks" title="Unlogg Hooks">
    A collection of custom React hooks for building modern web
    applications.
  </Card>
</Cards>


# Overview
URL: /unlogg-hooks

A collection of reusable hooks for building dashboard and web apps.

## What are unlogg/hooks?

**unlogg/hooks** is a collection of reusable hooks for building dashboard and web apps. It’s a great way to speed up your development process and create a consistent look and feel across your site.

## How are the hooks built?

All the hooks are built with `React` and are designed to be easy to use and customize. They’re built with TypeScript, so you get all the benefits of type safety and autocompletion in your IDE.

## Can I customize the hooks?

YES! You can customize the hooks however you like!

Since this is a "copy-paste" library, you can easily copy the hooks' code and paste it into your project (or install via the CLI). You can then modify the code to fit your needs, or use the hooks as a starting point for building your own.

## License

**unlogg/hooks** is licensed under the MIT License. You are free to use it in personal and commercial projects. If you find it useful, please consider giving back by contributing to the project or spreading the word.

For more info see the [LICENSE](https://github.com/unlogg/blob/main/LICENSE) file.

## FAQ

<Accordions>
  <Accordion title="Can I use this in my project?">
    Definitely! **unlogg/hooks** is free for personal and commercial projects.
    For more info see the [LICENSE](https://github.com/unlogg/blob/main/LICENSE) file.
  </Accordion>

  <Accordion title="Is this project ready to use?">
    Almost! We’re constantly adding new hooks and improving existing ones.
    You can of course use what’s here now, but be aware that things might change a little bit.
  </Accordion>

  <Accordion title="Can I contribute?">
    Yes, we'd love your help! You can open an issue or submit a pull request on our GitHub repository.

    Check [CONTRIBUTING.md](https://github.com/unlogg/blob/main/CONTRIBUTING.md) for more information on how to contribute.
  </Accordion>
</Accordions>


# Installation
URL: /unlogg-hooks/installation

How to use unlogg/hooks in your project

**No installation is required!  🎉**

Since this is a "copy-paste" collection of hooks, you can easily copy the components' code and paste it into your project

You can then modify the code to fit your needs, or use the components as a starting point for building your own.

If you want, you can use the [CLI](/docs/unlogg-ui/cli) to quickly add hooks to your projects.
(This is the same guide and CLI we use for `unlogg/ui`)


# useBoolean
URL: /unlogg-hooks/state/use-boolean

A custom React hook to manage boolean state with toggle functionality.

## Example

<ComponentPreview name="use-boolean-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-boolean" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-boolean" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-boolean" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage boolean state with built-in toggle functionality.
* Includes functions to set the state to `true`, `false`, or toggle the current state

## API Reference

### Parameters

<TypeTable
  type={{
  defaultValue: {
    description: "The initial boolean value for the state.",
    type: "boolean",
    default: "false",
  },
}}
/>

### Returns

<TypeTable
  type={{
  value: {
    description: "The current boolean state value.",
    type: "boolean",
  },
  setValue: {
    description: "Function to manually set the boolean state.",
    type: "React.Dispatch<React.SetStateAction<boolean>>",
  },
  setTrue: {
    description: "Function to set the state to `true`.",
    type: "() => void",
  },
  setFalse: {
    description: "Function to set the state to `false`.",
    type: "() => void",
  },
  toggle: {
    description: "Function to toggle the boolean state.",
    type: "() => void",
  },
}}
/>


# useCountdown
URL: /unlogg-hooks/state/use-countdown

A custom React hook to manage countdown timers.

## Example

<ComponentPreview name="use-countdown-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-countdown" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-countdown" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-countdown" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage countdown timers.
* Includes functions to start, stop, and reset the countdown.

## API Reference

### Parameters

<TypeTable
  type={{
  options: {
    description: "Configuration options for the countdown.",
    type: "UseCountdownOptions",
    default: "—",
  },
  "options.countStart": {
    description: "The initial value to start counting down from.",
    type: "number",
    default: "—",
  },
  "options.intervalMs": {
    description: "The interval in milliseconds between countdown ticks.",
    type: "number",
    default: "1000",
  },
  "options.onComplete": {
    description: "Optional callback invoked when the countdown reaches zero.",
    type: "() => void",
    default: "undefined",
  },
}}
/>

### Returns

<TypeTable
  type={{
  count: {
    description: "The current countdown value.",
    type: "number",
  },
  "handlers.startCountdown": {
    description: "Function to start the countdown if count is greater than zero.",
    type: "() => void",
  },
  "handlers.stopCountdown": {
    description: "Function to stop the countdown and clear the interval.",
    type: "() => void",
  },
  "handlers.resetCountdown": {
    description: "Function to reset the countdown to initial value and stop it.",
    type: "() => void",
  },
  "handlers.isActive": {
    description: "Boolean indicating if the countdown is currently active.",
    type: "boolean",
  },
}}
/>


# useCounter
URL: /unlogg-hooks/state/use-counter

A custom React hook to manage counter state.

You can use the `useCounter` hook to increment, decrement, and reset the counter value, making it easy to implement counters in your components.

You can also configure the counter with optional parameters for minimum, maximum, and step values, allowing for more control over the counter behavior.

## Example

<ComponentPreview name="use-counter-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-countdown" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-counter" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-counter" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage counter state.
* Includes functions to increment, decrement, and reset the counter.
* Supports optional configuration for minimum, maximum, and step values.
* When `max` or `min` values are set, the counter will not exceed these limits when incrementing or decrementing.

## API Reference

### Parameters

<TypeTable
  type={{
  initialValue: {
    description: "The initial value for the counter.",
    type: "number",
    default: "0",
  },
  options: {
    description: "Optional configuration for the counter behavior.",
    type: "{ min?: number; max?: number; step?: number; }",
    default: "{}",
  },
}}
/>

### Returns

<TypeTable
  type={{
  count: {
    description: "The current counter value.",
    type: "number",
  },
  setCount: {
    description: "Function to manually set the counter value.",
    type: "React.Dispatch<React.SetStateAction<number>>",
  },
  increment: {
    description: "Function to increment the counter by the step value.",
    type: "() => void",
  },
  decrement: {
    description: "Function to decrement the counter by the step value.",
    type: "() => void",
  },
  reset: {
    description: "Function to reset the counter to the initial value.",
    type: "() => void",
  },
}}
/>


# useDebouncedCallback  
URL: /unlogg-hooks/state/use-debounced-callback

A custom React hook to debounce callback functions.

You can use the `useDebouncedCallback` hook to create a debounced version of a callback function. This is particularly useful when you want to limit the rate at which a function can be executed, such as in scenarios where a user is typing input or making API calls.

For example, in an API call scenario, you could use this hook to ensure that the API is not called on every keystroke but rather after the user has stopped typing for a specified delay.

The difference between `useDebouncedCallback` and `useDebouncedValue` is that the former is specifically designed for debouncing callback functions.

## Example

<ComponentPreview name="use-debounced-callback-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-debounced-callback" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-debounced-callback" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-debounced-callback" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

## API Reference

### Parameters

<TypeTable
  type={{
  callback: {
    description: "The function to debounce.",
    type: "(...args: any[]) => void",
    default: "—",
  },
  delay: {
    description: "The debounce delay in milliseconds.",
    type: "number",
    default: "—",
  },
}}
/>

### Returns

<TypeTable
  type={{
  "debouncedCallback": {
    description: "The debounced callback function.",
    type: "(...args: any[]) => void",
  },
  "handlers.cancel": {
    description: "Function to cancel any pending debounced callback.",
    type: "() => void",
  },
}}
/>


# useDebouncedValue
URL: /unlogg-hooks/state/use-debounced-value

A custom React hook to manage debounced state values.

You can use the `useDebouncedValue` hook to manage state values that need to be debounced. This is particularly useful for scenarios like form inputs, where you want to avoid excessive updates while the user is typing.

For example, you can use this hook to debounce a search input value, ensuring that the search function is not called on every keystroke but rather *after* the user has stopped typing for a specified delay.

## Example

<ComponentPreview name="use-debounced-value-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-debounced-value" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-debounced-value" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-debounced-value" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## API Reference

### Parameters

<TypeTable
  type={{
  initialValue: {
    description: "The initial value to be debounced.",
    type: "T",
    default: "—",
  },
  delay: {
    description: "The debounce delay in milliseconds.",
    type: "number",
    default: "—",
  },
  options: {
    description: "Optional configuration object.",
    type: "{ onDebounce?: (value: T) => void }",
    default: "{}",
  },
}}
/>

### Returns

<TypeTable
  type={{
  "debouncedValue": {
    description: "The current debounced value.",
    type: "T",
  },
  "handlers.setValue": {
    description: "Function to manually set the value to be debounced.",
    type: "(val: T) => void",
  },
}}
/>


# useDisclosure
URL: /unlogg-hooks/state/use-disclosure

A react hook to manage boolean state with toggle functionality.

<ComponentPreview name="use-disclosure-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-disclosure" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-disclosure" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-disclosure" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

## API Reference

### Parameters

<TypeTable
  type={{
  defaultValue: {
    description: "The initial boolean value for the state.",
    type: "boolean",
    default: "false",
  },
}}
/>

### Returns

<TypeTable
  type={{
  value: {
    description: "The current boolean state value.",
    type: "boolean",
  },
  setValue: {
    description: "Function to manually set the boolean state.",
    type: "React.Dispatch<React.SetStateAction<boolean>>",
  },
  setTrue: {
    description: "Function to set the state to `true`.",
    type: "() => void",
  },
  setFalse: {
    description: "Function to set the state to `false`.",
    type: "() => void",
  },
  toggle: {
    description: "Function to toggle the boolean state.",
    type: "() => void",
  },
}}
/>


# useInterval
URL: /unlogg-hooks/state/use-interval

A custom React hook to manage interval functionality.

## Example

<ComponentPreview name="use-interval-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-interval" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-interval" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-interval" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage interval functionality.
* Includes functions to set the interval duration and trigger the interval.

## Examples

Use `useInterval` to create a simple countdown timer that updates every second:

<ComponentPreview name="use-interval-ex-02" classNameComponentContainer="min-h-[200px]" />

## API Reference

### Parameters

<TypeTable
  type={{
  callback: {
    description: "Function to be called at each interval.",
    type: "() => void",
    required: true,
  },
  delay: {
    description: "Delay in milliseconds for the interval. If null or not a number, the interval is not set.",
    type: "number | null",
    required: true,
  },
}}
/>


# useLocalStorage
URL: /unlogg-hooks/state/use-local-storage

Manage local storage with ease in React applications.

`useLocalStorage` provides a straightforward API to read and update values stored in `localStorage`, automatically handling JSON serialization and deserialization.

<ComponentPreview name="use-local-storage-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-local-storage" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-local-storage" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-local-storage" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Automatically initializes `localStorage` with a default value if the key does not exist.
* Handles JSON serialization and deserialization for complex data types.
* Provides a simple API for reading and updating values.
* Includes error handling for environments where `localStorage` is unavailable (e.g., server-side rendering).

## Examples

### Todo List with Persistence

<ComponentPreview name="use-local-storage-ex-02" classNameComponentContainer="min-h-[400px]" />

## Use Cases

* **Theme Preferences**: Store user's preferred color scheme, theme settings, or UI preferences
* **Form Data**: Persist form inputs to prevent data loss during accidental page refreshes
* **Shopping Cart**: Save cart items locally before user authentication
* **User Settings**: Store user-specific configuration options and preferences
* **Todo Lists**: Maintain task lists that persist across browser sessions
* **Recently Viewed**: Track recently accessed items or pages
* **Feature Flags**: Store client-side feature toggle states

## Server-Side Rendering

This hook checks if `localStorage` is available before accessing it. If used in a non-browser environment (e.g., during server-side rendering), it will return the `defaultValue` without attempting to access `localStorage`.

## API Reference

### Parameters

<TypeTable
  type={{
  key: {
    description: "The key used to store the value in local storage.",
    type: "string",
  },
  defaultValue: {
    description: "The default value to use if no value is found in local storage.",
    type: "T",
  },
}}
/>

### Returns

<TypeTable
  type={{
  value: {
    description: "The current value stored in local storage.",
    type: "T",
  },
  setValue: {
    description: "Function to update the value in local storage.",
    type: "(value: T) => void",
  },
}}
/>


# useStateHistory
URL: /unlogg-hooks/state/use-state-history

A custom React hook to manage state history with undo/redo functionality.

You can use the `useStateHistory` hook to manage state with built-in undo and redo functionality. This is particularly useful for applications where you need to track changes and allow users to revert to previous states, such as in form inputs or complex data structures.

## Example

<ComponentPreview name="use-state-history-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-state-history" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-state-history" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-state-history" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage state with built-in undo/redo functionality.
* Includes functions to set the state, go back, go forward, and clear the history.

## API Reference

### Parameters

<TypeTable
  type={{
  initialValue: {
    description: "The initial value for the state.",
    type: "T",
    default: "—",
  },
  options: {
    description: "Optional configuration for the state history behavior.",
    type: "{ maxHistorySize?: number; }",
    default: "{ maxHistorySize: 50 }",
  },
}}
/>

### Returns

<TypeTable
  type={{
  value: {
    description: "The current state value.",
    type: "T",
  },
  setValue: {
    description: "Function to set a new state value (adds to history).",
    type: "(value: T | (prev: T) => T) => void",
  },
  back: {
    description: "Go back one step in the history.",
    type: "() => void",
  },
  forward: {
    description: "Go forward one step in the history.",
    type: "() => void",
  },
  go: {
    description: "Go to a specific index in the history.",
    type: "(index: number) => void",
  },
  clear: {
    description: "Clear the history and reset to the initial value.",
    type: "() => void",
  },
  canGoBack: {
    description: "Boolean indicating if going back is possible.",
    type: "boolean",
  },
  canGoForward: {
    description: "Boolean indicating if going forward is possible.",
    type: "boolean",
  },
  history: {
    description: "Array of all history values.",
    type: "T[]",
  },
  currentIndex: {
    description: "Current position in the history.",
    type: "number",
  },
}}
/>


# useTimeout
URL: /unlogg-hooks/state/use-timeout

A custom React hook to manage timeout functionality.

## Example

<ComponentPreview name="use-timeout-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-timeout" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-timeout" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-timeout" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Provides a simple way to manage timeout functionality.
* Includes functions to set the timeout duration and trigger the timeout.

## API Reference

### Parameters

<TypeTable
  type={{
  callback: {
    description: "Function to be called after the specified delay.",
    type: "() => void",
    required: true,
  },
  delay: {
    description: "Delay in milliseconds before the callback is executed. If null, the timeout is not set.",
    type: "number | null",
    required: true,
  },
}}
/>


# useToggle
URL: /unlogg-hooks/state/use-toggle

A custom React hook to toggle between given values.

## Example

<ComponentPreview name="use-toggle-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-toggle" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-toggle" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-toggle" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Allows toggling between any set of values, not just `true` and `false`. You can provide an array of values to toggle between.

* Default to toggling between `false` and `true` if no options are provided.

* The `toggle` function can optionally accept a value to set directly, bypassing the toggle logic.

## API Reference

### Parameters

<TypeTable
  type={{
  options: {
    description: "An array of values to toggle between. Defaults to `[false, true]`.",
    type: "readonly T[]",
    default: "[false, true]",
  },
}}
/>

### Returns

<TypeTable
  type={{
  value: {
    description: "The current value of the toggle.",
    type: "T",
  },
  toggle: {
    description: "Function to toggle the value. Optionally accepts a value to set directly.",
    type: "(value?: React.SetStateAction<T>) => void",
  },
}}
/>


# useClickOutside
URL: /unlogg-hooks/ui-and-dom/use-click-outside

A custom React hook to detect clicks outside a specified element.

`useClickOutside` is a custom React hook that allows you to detect clicks outside of a specified element. This is particularly useful for closing dropdowns, modals, or any UI component when the user clicks outside of it.

## Example

<ComponentPreview name="use-click-outside-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="use-click-outside" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-click-outside" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-boolean" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* `useClickOutside` is useful for closing popovers, modals, dropdowns, or any UI element when a user clicks or taps outside of it.
* You can specify which events to listen for (e.g., `mousedown`, `touchstart`).
* You can provide additional nodes that should not trigger the outside click handler (e.g., buttons or other elements).
* The hook returns a ref that must be attached to the element you want to monitor for outside clicks.
* The handler will not be called if the click is inside the referenced element or any of the excluded nodes.

## API Reference

### Parameters

<TypeTable
  type={{
  handler: {
    description: "Function that is called on outside click.",
    type: "(event: Event) => void",
    required: true,
  },
  events: {
    description: "Optional list of events that trigger outside click.",
    type: "string[]",
    default: "['mousedown', 'touchstart']",
    required: false,
  },
  nodes: {
    description: "Optional list of nodes that should not trigger outside click event.",
    type: "(Element | null)[]",
    default: "[]",
    required: false,
  },
}}
/>

### Returns

<TypeTable
  type={{
  ref: {
    description: "A ref object that must be passed to the element based on which outside clicks should be captured.",
    type: "React.RefObject<T>",
  },
}}
/>


# useElementSize
URL: /unlogg-hooks/ui-and-dom/use-element-size

A custom React hook that tracks an elements size using ResizeObserver.

`useElementSize` is a custom React hook that tracks an element's size using the ResizeObserver API. It provides real-time updates when the element's dimensions change, making it perfect for responsive components that need to adapt based on their container size.

## Example

<ComponentPreview name="use-element-size-ex-01" classNameComponentContainer="min-h-[500px]" />

## Install

<ComponentInstall name="use-element-size" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-element-size" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-element-size" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Uses ResizeObserver for efficient size tracking
* Returns 0 for width and height on first render and during SSR
* Automatically cleans up the observer when component unmounts
* Works with any HTML element type through generics
* Provides rounded pixel values for consistent measurements

## API Reference

### Returns

<TypeTable
  type={{
  ref: {
    description: "A ref object that must be attached to the element you want to observe.",
    type: "React.RefObject<T | null>",
  },
  size: {
    description: "An object containing the current element dimensions.",
    type: "ElementSize",
  },
  "size.width": {
    description: "The current element width in pixels.",
    type: "number",
  },
  "size.height": {
    description: "The current element height in pixels.",
    type: "number",
  },
}}
/>

## Usage

```tsx
import { useElementSize } from "@/hooks/use-element-size";

function ResponsiveComponent() {
  const [ref, { width, height }] = useElementSize();

  return (
    <div ref={ref} className="resize-container">
      <p>Container size: {width} × {height}</p>
      {width > 300 && <AdditionalContent />}
    </div>
  );
}
```

## Advanced Usage

### Multiple Elements

You can use multiple instances to track different elements:

```tsx
function MultipleElements() {
  const [ref1, size1] = useElementSize();
  const [ref2, size2] = useElementSize();

  return (
    <div>
      <div ref={ref1}>Element 1: {size1.width}×{size1.height}</div>
      <div ref={ref2}>Element 2: {size2.width}×{size2.height}</div>
    </div>
  );
}
```

### Conditional Rendering

```tsx
function ConditionalContent() {
  const [ref, { width }] = useElementSize();

  return (
    <div ref={ref}>
      {width > 500 ? <DesktopLayout /> : <MobileLayout />}
    </div>
  );
}
```

## Use Cases

* **Container Queries**: Implement container-based responsive design without CSS container queries
* **Dynamic Layouts**: Adjust layout based on available space rather than viewport size
* **Canvas/SVG Sizing**: Automatically resize canvas or SVG elements to their container
* **Text Truncation**: Determine when to truncate text based on available space
* **Grid/Masonry Layouts**: Calculate optimal grid sizes based on container dimensions
* **Chart Responsiveness**: Resize charts and visualizations to fit their containers


# useHover
URL: /unlogg-hooks/ui-and-dom/use-hover

A custom React hook that detects if a given element is being hovered.

`useHover` is a custom React hook that detects when an element is being hovered. It accepts a ref object pointing to the element you want to monitor and returns a boolean indicating the hover state. This is useful for creating interactive UI elements that respond to mouse hover events.

## Example

<ComponentPreview name="use-hover-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-hover" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-hover" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-hover" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Accepts a ref object pointing to the element to monitor
* Returns a boolean indicating hover state
* Automatically handles event listener cleanup
* Works with any HTML element type through generics
* Uses native `mouseenter` and `mouseleave` events for reliable detection

## API Reference

### Parameters

<TypeTable
  type={{
  elementRef: {
    description: "A ref object pointing to the element to observe for hover state.",
    type: "React.RefObject<T | null>",
    default: "—",
  },
}}
/>

### Returns

<TypeTable
  type={{
  isHovered: {
    description: "A boolean indicating whether the element is currently being hovered.",
    type: "boolean",
  },
}}
/>

## Usage

```tsx
import { useRef } from "react";
import { useHover } from "@/hooks/use-hover";

function HoverableComponent() {
  const hoverRef = useRef(null);
  const isHover = useHover(hoverRef);

  return (
    <div 
      ref={hoverRef}
      className={isHover ? "bg-blue-100" : "bg-gray-100"}
    >
      {isHover ? "Hovering!" : "Not hovering"}
    </div>
  );
}
```

## Advanced Usage

### Multiple Elements

You can use multiple instances to track different elements:

```tsx
function MultipleHoverElements() {
  const button1Ref = useRef(null);
  const button2Ref = useRef(null);
  
  const isButton1Hovered = useHover(button1Ref);
  const isButton2Hovered = useHover(button2Ref);

  return (
    <div>
      <button ref={button1Ref}>
        Button 1 {isButton1Hovered && "🎯"}
      </button>
      <button ref={button2Ref}>
        Button 2 {isButton2Hovered && "🎯"}
      </button>
    </div>
  );
}
```

### Delayed Actions

Combine with `useEffect` for delayed hover actions:

```tsx
function DelayedHoverAction() {
  const elementRef = useRef(null);
  const isHovered = useHover(elementRef);
  const [showTooltip, setShowTooltip] = useState(false);

  useEffect(() => {
    let timer;
    
    if (isHovered) {
      timer = setTimeout(() => {
        setShowTooltip(true);
      }, 500); // Show tooltip after 500ms
    } else {
      setShowTooltip(false);
    }

    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [isHovered]);

  return (
    <div ref={elementRef}>
      Hover me
      {showTooltip && <div>Tooltip content</div>}
    </div>
  );
}
```

### Conditional Styling

```tsx
function ConditionalStyling() {
  const cardRef = useRef(null);
  const isHovered = useHover(cardRef);

  return (
    <div
      ref={cardRef}
      className={`
        transition-all duration-200
        ${isHovered 
          ? "scale-105 shadow-lg border-blue-300" 
          : "scale-100 shadow-sm border-gray-200"
        }
      `}
    >
      Interactive Card
    </div>
  );
}
```

## Use Cases

* **Interactive Cards**: Add hover effects to cards and tiles
* **Tooltip Triggers**: Show tooltips when elements are hovered
* **Button States**: Create enhanced button hover states
* **Image Overlays**: Show overlays when images are hovered
* **Navigation Items**: Highlight navigation items on hover
* **Form Field Enhancement**: Show additional information on form field hover
* **Data Visualization**: Highlight chart elements on hover
* **Progressive Disclosure**: Reveal additional content on hover


# useInViewport
URL: /unlogg-hooks/ui-and-dom/use-in-viewport

A custom React hook that detects if an element is in the viewport.

`useInViewport` is a custom React hook that detects when an element is in the viewport. It accepts a ref object pointing to the element you want to monitor and returns a boolean indicating the visibility state. This is useful for creating lazy-loaded components or triggering animations when an element comes into view.

## Example

<ComponentPreview name="use-in-viewport-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-in-viewport" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-in-viewport" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-in-viewport" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Returns an object with a callback `ref` to attach to the element you want to observe.
* Returns a boolean `inView` indicating if the element is currently in the viewport.
* Uses the Intersection Observer API under the hood.

## API Reference

### Parameters

<TypeTable
  type={{
  // No parameters; hook does not accept arguments.
}}
/>

### Returns

<TypeTable
  type={{
  ref: {
    description: "A callback ref to be attached to the target element.",
    type: "React.RefCallback<T | null>",
  },
  inView: {
    description: "A boolean indicating whether the element is currently in the viewport.",
    type: "boolean",
  },
}}
/>

## Usage

```tsx
import { useInViewport } from "@/hooks/use-in-viewport";

function InViewportComponent() {
  const { ref, inView } = useInViewport<HTMLDivElement>();

  return (
    <div 
      ref={ref}
      className={inView ? "bg-green-100" : "bg-gray-100"}
    >
      {inView ? "In viewport!" : "Out of viewport"}
    </div>
  );
}
```

## Use Cases

* **Lazy Loading**: Load images or components only when they enter the viewport
* **Animations**: Trigger animations when elements scroll into view
* **Infinite Scroll**: Detect when the user reaches the end of a list
* **Analytics**: Track when elements are actually viewed by users
* **Sticky Headers**: Activate sticky headers when they enter/leave the viewport
* **Progress Indicators**: Show progress as sections enter the viewport
* **Ad Visibility**: Measure ad impressions based on viewport entry
* **Reveal Effects**: Gradually reveal content as it scrolls into view
* **Button States**: Create enhanced button hover states
* **Image Overlays**: Show overlays when images are hovered
* **Navigation Items**: Highlight navigation items on hover
* **Form Field Enhancement**: Show additional information on form field hover
* **Data Visualization**: Highlight chart elements on hover
* **Progressive Disclosure**: Reveal additional content on hover


# useIsClient
URL: /unlogg-hooks/ui-and-dom/use-is-client

A custom React hook that determines if the code is running on the client side (in the browser).

`useIsClient` is a custom React hook that determines whether the code is running on the client side (in the browser) as opposed to the server. This hook is essential for SSR applications to prevent hydration mismatches and safely access browser-only APIs. It returns `false` during server-side rendering and `true` after the component mounts on the client.

## Example

<ComponentPreview name="use-is-client-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-is-client" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-is-client" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-is-client" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Returns `false` during server-side rendering and `true` after client hydration
* Prevents hydration mismatches in SSR applications
* Enables safe access to browser-only APIs like `window`, `document`, `localStorage`
* Automatically handles the server/client state transition
* Zero dependencies with minimal performance overhead

## API Reference

### Parameters

<TypeTable
  type={{
  "No parameters": {
    description: "This hook takes no parameters.",
    type: "—",
    default: "—",
  },
}}
/>

### Returns

<TypeTable
  type={{
  isClient: {
    description: "A boolean indicating whether the code is running on the client side.",
    type: "boolean",
  },
}}
/>

## Usage

```tsx
import { useIsClient } from "@/hooks/use-is-client";
```

## Advanced Usage

### Progressive Enhancement

You can use the hook to progressively enhance your components:

```tsx
function EnhancedComponent() {
  const isClient = useIsClient();

  return (
    <div>
      {/* Always rendered (core functionality) */}
      <BasicContent />
      
      {/* Progressive enhancement */}
      {isClient && (
        <>
          <InteractiveFeatures />
          <ClientOnlyWidgets />
        </>
      )}
    </div>
  );
}
```

### Safe Browser API Access

Combine with `useEffect` for safe browser API access:

```tsx
function BrowserInfo() {
  const isClient = useIsClient();
  const [info, setInfo] = useState(null);

  useEffect(() => {
    if (isClient) {
      // Safe to access browser APIs
      setInfo({
        userAgent: navigator.userAgent,
        language: navigator.language,
        onLine: navigator.onLine,
      });
    }
  }, [isClient]);

  if (!isClient) return <div>Loading browser info...</div>;

  return (
    <div>
      <p>Browser: {info?.userAgent}</p>
      <p>Language: {info?.language}</p>
      <p>Online: {info?.onLine ? "Yes" : "No"}</p>
    </div>
  );
}
```

### Preventing Layout Shift

Use placeholders to prevent layout shift during hydration:

```tsx
function ResponsiveComponent() {
  const isClient = useIsClient();

  return (
    <div>
      {!isClient ? (
        // Placeholder with same dimensions
        <div className="h-48 bg-gray-200 animate-pulse rounded" />
      ) : (
        <DynamicContent />
      )}
    </div>
  );
}
```

### Local Storage Integration

```tsx
function UserPreferences() {
  const isClient = useIsClient();
  const [theme, setTheme] = useState('light');

  useEffect(() => {
    if (isClient) {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        setTheme(savedTheme);
      }
    }
  }, [isClient]);

  const updateTheme = (newTheme: string) => {
    setTheme(newTheme);
    if (isClient) {
      localStorage.setItem('theme', newTheme);
    }
  };

  return (
    <div className={`theme-${theme}`}>
      <button onClick={() => updateTheme(theme === 'light' ? 'dark' : 'light')}>
        {isClient ? `Switch to ${theme === 'light' ? 'dark' : 'light'} theme` : 'Loading...'}
      </button>
    </div>
  );
}
```

## Use Cases

* **Server-Side Rendering**: Prevent hydration mismatches in Next.js, Remix, or other SSR frameworks
* **Progressive Enhancement**: Add client-only features without breaking server rendering
* **Browser API Access**: Safely use `window`, `document`, `localStorage`, `sessionStorage`, etc.
* **Third-Party Widgets**: Conditionally render client-only components like maps, charts, or social widgets
* **Feature Detection**: Enable features only when JavaScript is available
* **Performance Optimization**: Defer heavy client-side components until after hydration
* **Conditional Imports**: Load client-only libraries or components dynamically
* **Analytics Integration**: Initialize tracking scripts only on the client side


# useMediaQuery
URL: /unlogg-hooks/ui-and-dom/use-media-query

A custom React hook that tracks the state of a media query using the Match Media API.

`useMediaQuery` is a custom React hook that tracks the state of a CSS media query using the browser's Match Media API. It provides a simple boolean interface to conditionally render content or apply logic based on media queries like screen size, user preferences, or device capabilities.

## Example

<ComponentPreview name="use-media-query-ex-01" classNameComponentContainer="min-h-[800px]" />

## Install

<ComponentInstall name="use-media-query" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-media-query" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-media-query" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Uses the browser's native `matchMedia` API for efficient media query tracking
* Automatically handles server-side rendering scenarios
* Provides options for SSR-safe initialization
* Cleans up event listeners automatically on unmount
* Supports all standard CSS media query features

## API Reference

### Parameters

<TypeTable
  type={{
  query: {
    description: "The media query to track.",
    type: "string",
    default: "—",
  },
  options: {
    description: "The options for customizing the behavior of the hook (optional).",
    type: "UseMediaQueryOptions",
    default: "{}",
  },
  "options.defaultValue": {
    description: "The default value to return if the hook is being run on the server.",
    type: "boolean",
    default: "false",
  },
  "options.initializeWithValue": {
    description: "If true (default), the hook will initialize reading the media query. In SSR, you should set it to false, returning options.defaultValue or false initially.",
    type: "boolean",
    default: "true",
  },
}}
/>

### Returns

<TypeTable
  type={{
  matches: {
    description: "The current state of the media query (true if the query matches, false otherwise).",
    type: "boolean",
  },
}}
/>

## Usage

### Basic Usage

```tsx
import { useMediaQuery } from "@/hooks/use-media-query";

function ResponsiveComponent() {
  const isMobile = useMediaQuery('(max-width: 768px)');
  const isDarkMode = useMediaQuery('(prefers-color-scheme: dark)');
  const prefersReducedMotion = useMediaQuery('(prefers-reduced-motion: reduce)');

  return (
    <div>
      {isMobile ? <MobileLayout /> : <DesktopLayout />}
      {isDarkMode && <p>Dark mode is enabled</p>}
      {prefersReducedMotion && <p>Reduced motion preferred</p>}
    </div>
  );
}
```

### SSR-Safe Usage

```tsx
function SSRComponent() {
  const isMobile = useMediaQuery('(max-width: 768px)', {
    defaultValue: false,
    initializeWithValue: false
  });

  return (
    <div>
      {isMobile ? 'Mobile View' : 'Desktop View'}
    </div>
  );
}
```

## Common Media Queries

### Breakpoints

```tsx
// Standard breakpoints
const isMobile = useMediaQuery('(max-width: 640px)');
const isTablet = useMediaQuery('(min-width: 641px) and (max-width: 1024px)');
const isDesktop = useMediaQuery('(min-width: 1025px)');
const isLarge = useMediaQuery('(min-width: 1280px)');

// Custom breakpoints
const isSmall = useMediaQuery('(max-width: 480px)');
const isWide = useMediaQuery('(min-width: 1600px)');
```

### User Preferences

```tsx
// Color scheme
const isDark = useMediaQuery('(prefers-color-scheme: dark)');
const isLight = useMediaQuery('(prefers-color-scheme: light)');

// Motion preferences
const prefersReducedMotion = useMediaQuery('(prefers-reduced-motion: reduce)');

// Contrast preferences
const highContrast = useMediaQuery('(prefers-contrast: high)');
const lowContrast = useMediaQuery('(prefers-contrast: low)');
```

### Device Capabilities

```tsx
// Orientation
const isPortrait = useMediaQuery('(orientation: portrait)');
const isLandscape = useMediaQuery('(orientation: landscape)');

// Input capabilities
const canHover = useMediaQuery('(hover: hover)');
const hasPointer = useMediaQuery('(pointer: fine)');

// Display capabilities
const isRetina = useMediaQuery('(min-resolution: 2dppx)');
const isPrint = useMediaQuery('print');
```

## Advanced Examples

### Responsive Layout Hook

```tsx
function useResponsiveLayout() {
  const isMobile = useMediaQuery('(max-width: 640px)');
  const isTablet = useMediaQuery('(min-width: 641px) and (max-width: 1024px)');
  const isDesktop = useMediaQuery('(min-width: 1025px)');

  return {
    isMobile,
    isTablet,
    isDesktop,
    columns: isMobile ? 1 : isTablet ? 2 : 3,
    showSidebar: isDesktop,
    compactLayout: isMobile || isTablet
  };
}
```

### Theme-Aware Component

```tsx
function ThemeAwareComponent() {
  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)');
  const prefersHighContrast = useMediaQuery('(prefers-contrast: high)');
  
  const theme = React.useMemo(() => ({
    dark: prefersDark,
    highContrast: prefersHighContrast,
    className: `
      ${prefersDark ? 'dark' : 'light'}
      ${prefersHighContrast ? 'high-contrast' : ''}
    `.trim()
  }), [prefersDark, prefersHighContrast]);

  return (
    <div className={theme.className}>
      <p>Theme-aware content</p>
    </div>
  );
}
```

### Performance-Aware Component

```tsx
function PerformanceAwareComponent() {
  const prefersReducedMotion = useMediaQuery('(prefers-reduced-motion: reduce)');
  const isLowEndDevice = useMediaQuery('(max-device-memory: 1)');
  const isSlowConnection = useMediaQuery('(prefers-reduced-data: reduce)');

  const shouldOptimize = prefersReducedMotion || isLowEndDevice || isSlowConnection;

  return (
    <div>
      {shouldOptimize ? (
        <StaticContent />
      ) : (
        <AnimatedContent />
      )}
    </div>
  );
}
```

## TypeScript

The hook is fully typed and exports its option types:

```tsx
import { useMediaQuery, UseMediaQueryOptions } from "@/hooks/use-media-query";

const options: UseMediaQueryOptions = {
  defaultValue: false,
  initializeWithValue: true
};

const isMobile: boolean = useMediaQuery('(max-width: 768px)', options);
```

## Use Cases

* **Responsive Design**: Conditional rendering based on screen size
* **Accessibility**: Respecting user preferences for motion, contrast, etc.
* **Performance Optimization**: Adapting content for device capabilities
* **Progressive Enhancement**: Enabling features based on device support
* **Theme Detection**: Automatically adapting to system color scheme
* **Print Styles**: Conditional rendering for print media
* **Device Orientation**: Adapting layout for portrait/landscape
* **Touch vs Mouse**: Different interactions for different input methods


# useMobile
URL: /unlogg-hooks/ui-and-dom/use-mobile

A custom React hook that detects if the current screen width is below a mobile breakpoint.

`useMobile` is a custom React hook that provides a simple boolean interface to detect if the current screen width is below a specified mobile breakpoint. It uses window resize events to track screen size changes and offers configurable breakpoint values with SSR support.

<ComponentPreview name="use-mobile-ex-01" classNameComponentContainer="min-h-[700px]" />

## Install

<ComponentInstall name="use-mobile" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-mobile" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-mobile" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Uses window resize events for efficient mobile detection
* Configurable breakpoint value (default: 768px)
* Automatically handles server-side rendering scenarios
* Provides options for SSR-safe initialization
* Cleans up event listeners automatically on unmount

## Examples

### Layout with breakpoints

<ComponentPreview name="use-mobile-ex-02" classNameComponentContainer="min-h-[700px]" />

### Layout with custom breakpoints

<ComponentPreview name="use-mobile-ex-03" classNameComponentContainer="min-h-[700px]" />

## API Reference

### Parameters

<TypeTable
  type={{
  breakpoint: {
    description: "The pixel value to use as the mobile breakpoint.",
    type: "number",
    default: "768",
  },
  options: {
    description: "The options for customizing the behavior of the hook (optional).",
    type: "UseMobileOptions",
    default: "{}",
  },
  "options.defaultValue": {
    description: "The default value to return if the hook is being run on the server.",
    type: "boolean",
    default: "false",
  },
  "options.initializeWithValue": {
    description: "If true (default), the hook will initialize reading the screen width. In SSR, you should set it to false, returning options.defaultValue or false initially.",
    type: "boolean",
    default: "true",
  },
}}
/>

### Returns

<TypeTable
  type={{
  isMobile: {
    description: "A boolean indicating whether the screen width is below the mobile breakpoint.",
    type: "boolean",
  },
}}
/>

## Usage

### Basic Usage

```tsx
import { useMobile } from "@/hooks/use-mobile";

function ResponsiveComponent() {
  const isMobile = useMobile(); // Uses default 768px breakpoint
  const isSmallMobile = useMobile(640); // Custom 640px breakpoint
  const isLargeMobile = useMobile(1024); // Large mobile/tablet breakpoint

  return (
    <div>
      {isMobile ? <MobileLayout /> : <DesktopLayout />}
      {isSmallMobile && <CompactContent />}
      {isLargeMobile && <TabletOptimizedContent />}
    </div>
  );
}
```

### SSR-Safe Usage

```tsx
function SSRComponent() {
  const isMobile = useMobile(768, {
    defaultValue: false,
    initializeWithValue: false
  });

  return (
    <div>
      {isMobile ? 'Mobile View' : 'Desktop View'}
    </div>
  );
}
```

## Common Breakpoints

```tsx
// Extra small devices (phones)
const isXS = useMobile(480);

// Small devices (large phones)
const isSM = useMobile(640);

// Medium devices (tablets)
const isMD = useMobile(768); // Default

// Large devices (small desktops)
const isLG = useMobile(1024);

// Extra large devices (large desktops)
const isXL = useMobile(1280);
```

## Advanced Examples

### Responsive Navigation

```tsx
function Navigation() {
  const isMobile = useMobile(768);

  return (
    <nav>
      {isMobile ? (
        <MobileMenu />
      ) : (
        <DesktopMenu />
      )}
    </nav>
  );
}
```

### Conditional Content Loading

```tsx
function ContentSection() {
  const isMobile = useMobile(768);
  const isSmallScreen = useMobile(480);

  return (
    <section>
      {isSmallScreen ? (
        <MinimalContent />
      ) : isMobile ? (
        <MobileContent />
      ) : (
        <FullContent />
      )}
    </section>
  );
}
```

### Multi-Breakpoint Layout

```tsx
function useResponsiveLayout() {
  const isXS = useMobile(480);
  const isSM = useMobile(640);
  const isMD = useMobile(768);
  const isLG = useMobile(1024);

  const getLayout = () => {
    if (isXS) return { columns: 1, showSidebar: false, compact: true };
    if (isSM) return { columns: 1, showSidebar: false, compact: false };
    if (isMD) return { columns: 2, showSidebar: false, compact: false };
    if (isLG) return { columns: 2, showSidebar: true, compact: false };
    return { columns: 3, showSidebar: true, compact: false };
  };

  return getLayout();
}

function ResponsiveLayout() {
  const layout = useResponsiveLayout();

  return (
    <div className={`grid grid-cols-${layout.columns}`}>
      <main>Main content</main>
      {layout.showSidebar && <aside>Sidebar</aside>}
    </div>
  );
}
```

### Performance Optimization

```tsx
function OptimizedComponent() {
  const isMobile = useMobile(768);

  // Only load heavy components on desktop
  const HeavyComponent = React.useMemo(() => {
    if (isMobile) return null;
    return React.lazy(() => import('./HeavyComponent'));
  }, [isMobile]);

  return (
    <div>
      {isMobile ? (
        <LightweightMobileComponent />
      ) : (
        <React.Suspense fallback={<Loading />}>
          {HeavyComponent && <HeavyComponent />}
        </React.Suspense>
      )}
    </div>
  );
}
```

## Comparison with useMediaQuery

While `useMediaQuery` provides more flexibility for complex media queries, `useMobile` offers a simpler API specifically for mobile detection:

```tsx
// Using useMediaQuery
const isMobile = useMediaQuery('(max-width: 768px)');

// Using useMobile (simpler)
const isMobile = useMobile(768);

// Custom breakpoint with useMobile
const isTablet = useMobile(1024);
```

## Use Cases

* **Responsive Navigation**: Show/hide mobile menu vs desktop navigation
* **Layout Adaptation**: Switch between single-column and multi-column layouts
* **Content Optimization**: Load different content for mobile vs desktop
* **Performance**: Conditionally load heavy components only on desktop
* **Touch Optimization**: Enable touch-friendly interfaces on mobile
* **Image Loading**: Load different image sizes based on screen size
* **Form Layout**: Adapt form layouts for mobile vs desktop
* **Component Visibility**: Show/hide components based on screen size


# useScrollIntoView
URL: /unlogg-hooks/ui-and-dom/use-scroll-into-view

A custom React hook that handles scroll behavior for any scrollable element with animation and reduced-motion support.

`useScrollIntoView` is a custom React hook that provides smooth scrolling functionality to any element. It works similarly to the native `element.scrollIntoView()` method but with enhanced features including automatic reduced-motion detection and customizable scroll behavior.

<ComponentPreview name="use-scroll-into-view-ex-01" classNameComponentContainer="min-h-[700px]" />

## Install

<ComponentInstall name="use-scroll-into-view" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-scroll-into-view" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-scroll-into-view" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Automatically respects `prefers-reduced-motion` user preference
* Uses `requestAnimationFrame` for smooth execution
* Provides cancel functionality for ongoing scroll animations
* Works with any scrollable container
* Supports all native `scrollIntoView` options

## Examples

### Scroll navigation between sections

<ComponentPreview name="use-scroll-into-view-ex-02" classNameComponentContainer="min-h-[700px]" />

## API Reference

### Parameters

<TypeTable
  type={{
  options: {
    description: "Optional scroll configuration options.",
    type: "ScrollIntoViewOptions",
    default: "{ behavior: 'smooth', block: 'start', inline: 'nearest' }",
  },
  "options.behavior": {
    description: "Scroll behavior ('auto' or 'smooth').",
    type: "'auto' | 'smooth'",
    default: "'smooth'",
  },
  "options.block": {
    description: "Vertical alignment of the element.",
    type: "'start' | 'center' | 'end' | 'nearest'",
    default: "'start'",
  },
  "options.inline": {
    description: "Horizontal alignment of the element.",
    type: "'start' | 'center' | 'end' | 'nearest'",
    default: "'nearest'",
  },
}}
/>

### Returns

<TypeTable
  type={{
  ref: {
    description: "A ref object that must be attached to the element you want to scroll to.",
    type: "React.RefObject<T | null>",
  },
  handlers: {
    description: "An object containing scroll control functions.",
    type: "UseScrollIntoViewReturn",
  },
  "handlers.scrollIntoView": {
    description: "Function to trigger scrolling with optional override options.",
    type: "(options?: ScrollIntoViewOptions) => void",
  },
  "handlers.cancel": {
    description: "Function to cancel ongoing smooth scrolling.",
    type: "() => void",
  },
}}
/>

## Usage

```tsx
import { useScrollIntoView } from "@/hooks/use-scroll-into-view";

function ScrollExample() {
  const [targetRef, { scrollIntoView }] = useScrollIntoView({
    behavior: "smooth",
    block: "center",
  });

  return (
    <div>
      <button onClick={() => scrollIntoView()}>
        Scroll to target
      </button>
      <div style={{ height: "200vh" }}>
        <div ref={targetRef}>Target element</div>
      </div>
    </div>
  );
}
```

## Advanced Usage

### Navigation Menu

```tsx
function NavigationMenu() {
  const [homeRef, { scrollIntoView: scrollToHome }] = useScrollIntoView({
    behavior: "smooth",
    block: "start",
  });
  
  const [aboutRef, { scrollIntoView: scrollToAbout }] = useScrollIntoView({
    behavior: "smooth",
    block: "center",
  });

  return (
    <div>
      <nav>
        <button onClick={() => scrollToHome()}>Home</button>
        <button onClick={() => scrollToAbout()}>About</button>
      </nav>
      
      <section ref={homeRef}>Home Content</section>
      <section ref={aboutRef}>About Content</section>
    </div>
  );
}
```

### Override Options

```tsx
function FlexibleScroll() {
  const [targetRef, { scrollIntoView }] = useScrollIntoView();

  return (
    <div>
      <button 
        onClick={() => scrollIntoView({ behavior: "auto", block: "start" })}
      >
        Instant scroll to top
      </button>
      <button 
        onClick={() => scrollIntoView({ behavior: "smooth", block: "center" })}
      >
        Smooth scroll to center
      </button>
      <div ref={targetRef}>Target</div>
    </div>
  );
}
```

### With Scroll Cancellation

```tsx
function CancellableScroll() {
  const [targetRef, { scrollIntoView, cancel }] = useScrollIntoView();

  const handleSlowScroll = () => {
    scrollIntoView({ behavior: "smooth" });
    
    // Cancel after 1 second if needed
    setTimeout(() => {
      cancel();
    }, 1000);
  };

  return (
    <div>
      <button onClick={handleSlowScroll}>Start scroll</button>
      <button onClick={cancel}>Cancel scroll</button>
      <div ref={targetRef}>Target</div>
    </div>
  );
}
```

## Accessibility

The hook automatically respects the user's `prefers-reduced-motion` setting:

* When `prefers-reduced-motion: reduce` is set, smooth scrolling is automatically disabled
* All scroll animations become instant (`behavior: "auto"`)
* This ensures a comfortable experience for users with motion sensitivity

## Use Cases

* **Single Page Navigation**: Create smooth scrolling between sections
* **Documentation Sites**: Table of contents navigation
* **Landing Pages**: Smooth scrolling to different sections
* **Form Navigation**: Jump to form sections or error fields
* **Image Galleries**: Navigate between gallery items
* **Timeline Components**: Scroll to specific timeline events
* **Chat Applications**: Scroll to latest messages or specific conversations
* **Data Tables**: Scroll to specific rows or columns


# useWindowSize
URL: /unlogg-hooks/ui-and-dom/use-window-size

A custom React hook that tracks the current window size and updates on resize.

`useWindowSize` is a custom React hook that tracks the current window size and provides real-time updates when the window is resized. This is particularly useful for creating responsive components that need to adapt to different screen sizes.

## Example

<ComponentPreview name="use-window-size-ex-01" classNameComponentContainer="min-h-[400px]" />

## Install

<ComponentInstall name="use-window-size" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-window-size" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-window-size" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Automatically updates when the window is resized
* Returns both width and height as numbers
* Handles the resize event listener cleanup properly
* Initializes with the current window size on mount

## API Reference

### Returns

<TypeTable
  type={{
  width: {
    description: "The current window width in pixels.",
    type: "number",
  },
  height: {
    description: "The current window height in pixels.",
    type: "number",
  },
}}
/>

## Usage

```tsx
import { useWindowSize } from "@/hooks/use-window-size";

function ResponsiveComponent() {
  const { width, height } = useWindowSize();

  if (width < 768) {
    return <MobileView />;
  }

  return <DesktopView />;
}
```

## Use Cases

* **Responsive Components**: Create components that adapt based on screen size without relying solely on CSS media queries
* **Layout Calculations**: Perform calculations that depend on the current viewport size
* **Performance Optimization**: Conditionally render expensive components only on larger screens
* **Dynamic Styling**: Apply different styles or behaviors based on window dimensions


# useClipboardCopy
URL: /unlogg-hooks/utilities/use-clipboard-copy

A custom React hook that provides clipboard copy functionality with state management and error handling.

`useClipboardCopy` is a custom React hook that provides an easy way to copy text to the clipboard with automatic state management. It tracks the copied state, handles errors gracefully, and automatically resets the state after a configurable timeout. The hook uses the modern Clipboard API under the hood for reliable functionality.

## Example

<ComponentPreview name="use-clipboard-copy-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-clipboard-copy" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-clipboard-copy" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-clipboard-copy" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Uses the modern Clipboard API (`navigator.clipboard.writeText`)
* Automatically tracks copied state with configurable timeout
* Provides comprehensive error handling for clipboard failures
* Includes success and error callbacks for custom behavior
* Supports manual state reset functionality
* Works with any text content including code, URLs, and emojis

## API Reference

### Parameters

<TypeTable
  type={{
  options: {
    description: "Configuration options for the clipboard copy behavior.",
    type: "UseClipboardCopyOptions",
    default: "{}",
  },
}}
/>

### UseClipboardCopyOptions

<TypeTable
  type={{
  timeout: {
    description: "The timeout in milliseconds after which the copied state resets to false.",
    type: "number",
    default: "2000",
  },
  onSuccess: {
    description: "Callback function called when text is successfully copied.",
    type: "(text: string) => void",
    default: "undefined",
  },
  onError: {
    description: "Callback function called when copying fails.",
    type: "(error: Error) => void",
    default: "undefined",
  },
}}
/>

### Returns

<TypeTable
  type={{
  copied: {
    description: "Whether text was recently copied (true for the duration of the timeout).",
    type: "boolean",
  },
  copy: {
    description: "Function to copy text to the clipboard.",
    type: "(text: string) => Promise<void>",
  },
  error: {
    description: "The error that occurred during copying, if any.",
    type: "Error | null",
  },
  reset: {
    description: "Function to manually reset the copied state.",
    type: "() => void",
  },
}}
/>

## Usage

```tsx
import { useClipboardCopy } from "@/hooks/use-clipboard-copy";

function CopyButton() {
  const { copy, copied, error } = useClipboardCopy({
    timeout: 2000,
    onSuccess: (text) => console.log('Copied:', text),
    onError: (err) => console.error('Copy failed:', err)
  });

  const handleCopy = () => {
    copy('Hello, World!');
  };

  return (
    <button onClick={handleCopy}>
      {copied ? 'Copied!' : 'Copy'}
      {error && <span>Failed to copy</span>}
    </button>
  );
}
```

## Advanced Usage

### Code Block with Copy Button

Create a reusable code block component with copy functionality:

```tsx
function CodeBlock({ code, language }: { code: string; language: string }) {
  const { copy, copied } = useClipboardCopy({ timeout: 3000 });

  return (
    <div className="relative">
      <pre className={`language-${language}`}>
        <code>{code}</code>
      </pre>
      <button
        onClick={() => copy(code)}
        className="absolute top-2 right-2"
      >
        {copied ? '✓ Copied!' : 'Copy Code'}
      </button>
    </div>
  );
}
```

### URL Sharing Component

Combine with other hooks for URL sharing functionality:

```tsx
function ShareURL() {
  const { copy, copied, error } = useClipboardCopy({
    timeout: 1500,
    onSuccess: () => toast.success('URL copied to clipboard!'),
    onError: () => toast.error('Failed to copy URL')
  });
  
  const currentURL = window.location.href;

  return (
    <div className="flex gap-2">
      <input value={currentURL} readOnly className="flex-1" />
      <button onClick={() => copy(currentURL)}>
        {copied ? '✓ Copied' : 'Share URL'}
      </button>
      {error && <span className="text-red-500">Error: {error.message}</span>}
    </div>
  );
}
```

### Multi-Text Copy Manager

Handle multiple copyable items with individual state tracking:

```tsx
function ContactCard({ contact }: { contact: Contact }) {
  const emailCopy = useClipboardCopy({ timeout: 2000 });
  const phoneCopy = useClipboardCopy({ timeout: 2000 });
  const addressCopy = useClipboardCopy({ timeout: 2000 });

  return (
    <div className="space-y-2">
      <div className="flex justify-between">
        <span>Email: {contact.email}</span>
        <button onClick={() => emailCopy.copy(contact.email)}>
          {emailCopy.copied ? '✓' : 'Copy'}
        </button>
      </div>
      <div className="flex justify-between">
        <span>Phone: {contact.phone}</span>
        <button onClick={() => phoneCopy.copy(contact.phone)}>
          {phoneCopy.copied ? '✓' : 'Copy'}
        </button>
      </div>
      <div className="flex justify-between">
        <span>Address: {contact.address}</span>
        <button onClick={() => addressCopy.copy(contact.address)}>
          {addressCopy.copied ? '✓' : 'Copy'}
        </button>
      </div>
    </div>
  );
}
```

### Error Handling and Fallbacks

Implement graceful fallbacks for unsupported browsers:

```tsx
function RobustCopyButton({ text }: { text: string }) {
  const { copy, copied, error, reset } = useClipboardCopy({
    timeout: 3000,
    onError: (err) => {
      console.error('Clipboard copy failed:', err);
      // Implement fallback logic
      fallbackCopyToClipboard(text);
    }
  });

  const fallbackCopyToClipboard = (text: string) => {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (err) {
      console.error('Fallback copy failed:', err);
    }
    document.body.removeChild(textArea);
  };

  return (
    <div>
      <button onClick={() => copy(text)}>
        {copied ? '✓ Copied!' : 'Copy Text'}
      </button>
      {error && (
        <div className="text-red-500 text-sm">
          Copy failed. Please try selecting and copying manually.
          <button onClick={reset} className="underline ml-2">
            Dismiss
          </button>
        </div>
      )}
    </div>
  );
}
```

## Use Cases

* **Code Documentation**: Add copy buttons to code examples and snippets
* **URL Sharing**: Allow users to easily copy and share URLs
* **Contact Information**: Enable copying of email addresses, phone numbers, and addresses
* **API Keys & Tokens**: Provide secure copying of sensitive information
* **Social Sharing**: Copy pre-formatted social media content
* **Form Data**: Allow copying of generated content like passwords or IDs
* **Error Messages**: Enable copying of error details for support requests
* **Configuration Values**: Copy configuration snippets and settings


# useDocumentTitle
URL: /unlogg-hooks/utilities/use-document-title

A custom React hook that sets the document title with React.useLayoutEffect.

`useDocumentTitle` is a custom React hook that sets the document title using `useLayoutEffect` for synchronous updates. It's designed for client-only applications and will not run during server-side rendering. The hook provides options for restoring the original title when the component unmounts, making it perfect for dynamic title management.

## Example

<ComponentPreview name="use-document-title-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-document-title" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-document-title" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-document-title" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Uses `useLayoutEffect` for synchronous DOM updates before paint
* Only runs on client-side (safe for SSR applications)
* Supports optional title restoration on component unmount
* Accepts null/undefined to skip title updates
* Stores original title for restoration purposes
* Ideal for client-only applications and dynamic title updates

## API Reference

### Parameters

<TypeTable
  type={{
  title: {
    description: "The title to set for the document. If null or undefined, the title won't be changed.",
    type: "string | null | undefined",
    default: "—",
  },
  options: {
    description: "Configuration options for the hook behavior.",
    type: "object",
    default: "{}",
  },
}}
/>

### Options

<TypeTable
  type={{
  restoreOnUnmount: {
    description: "Whether to restore the previous title when the component unmounts.",
    type: "boolean",
    default: "false",
  },
}}
/>

### Returns

<TypeTable
  type={{
  "void": {
    description: "This hook does not return any value.",
    type: "void",
  },
}}
/>

## Usage

```tsx
import { useDocumentTitle } from "@/hooks/use-document-title";

function MyPage() {
  useDocumentTitle("My Page Title");
  
  return <div>Page content</div>;
}
```

## Advanced Usage

### Dynamic Title Updates

Update the title based on component state:

```tsx
function DynamicPage() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState(null);
  
  // Dynamic title based on state
  useDocumentTitle(
    user ? `${user.name}'s Dashboard (${count} items)` : `Dashboard (${count} items)`
  );
  
  return (
    <div>
      <h1>Dashboard</h1>
      <p>Items: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>
        Add Item
      </button>
    </div>
  );
}
```

### Conditional Title Setting

Set title only when certain conditions are met:

```tsx
function ConditionalTitle() {
  const [isImportant, setIsImportant] = useState(false);
  const [notification, setNotification] = useState(null);
  
  // Only set title when there's an important notification
  useDocumentTitle(
    isImportant && notification ? `🔔 ${notification}` : null
  );
  
  return (
    <div>
      <button onClick={() => setIsImportant(!isImportant)}>
        {isImportant ? "Mark Normal" : "Mark Important"}
      </button>
      <input 
        value={notification || ""}
        onChange={(e) => setNotification(e.target.value)}
        placeholder="Enter notification..."
      />
    </div>
  );
}
```

### Restore Original Title

Use the `restoreOnUnmount` option for temporary title changes:

```tsx
function TemporaryModal({ isOpen, onClose }) {
  // This will restore the original title when modal closes
  useDocumentTitle(
    isOpen ? "🎯 Important: Review Required" : null,
    { restoreOnUnmount: true }
  );
  
  if (!isOpen) return null;
  
  return (
    <div className="modal">
      <h2>Important Action Required</h2>
      <p>Please review the following...</p>
      <button onClick={onClose}>Close</button>
    </div>
  );
}
```

### Page Navigation with Breadcrumbs

Create breadcrumb-style titles for navigation:

```tsx
function ProductPage({ category, product }) {
  const title = useMemo(() => {
    const parts = ["MyStore"];
    if (category) parts.push(category.name);
    if (product) parts.push(product.name);
    return parts.join(" > ");
  }, [category, product]);
  
  useDocumentTitle(title);
  
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        {category && (
          <>
            <span> > </span>
            <Link to={`/category/${category.id}`}>{category.name}</Link>
          </>
        )}
        {product && (
          <>
            <span> > </span>
            <span>{product.name}</span>
          </>
        )}
      </nav>
      {/* Product content */}
    </div>
  );
}
```

### Real-time Updates

Update title with live data:

```tsx
function LiveCounter() {
  const [count, setCount] = useState(0);
  const [isActive, setIsActive] = useState(false);
  
  // Update title with current count when active
  useDocumentTitle(isActive ? `Live Count: ${count}` : null);
  
  useEffect(() => {
    if (!isActive) return;
    
    const interval = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);
    
    return () => clearInterval(interval);
  }, [isActive]);
  
  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => setIsActive(!isActive)}>
        {isActive ? "Stop" : "Start"} Live Title
      </button>
    </div>
  );
}
```

### Form with Validation Status

Show form status in the title:

```tsx
function ContactForm() {
  const [formData, setFormData] = useState({ name: "", email: "" });
  const [errors, setErrors] = useState({});
  const [isDirty, setIsDirty] = useState(false);
  
  const isValid = Object.keys(errors).length === 0;
  const titleSuffix = isDirty ? (isValid ? " ✓" : " ⚠️") : "";
  
  useDocumentTitle(`Contact Form${titleSuffix}`);
  
  const handleChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    setIsDirty(true);
    // Validation logic here...
  };
  
  return (
    <form>
      <input 
        value={formData.name}
        onChange={(e) => handleChange("name", e.target.value)}
        placeholder="Name"
      />
      <input 
        value={formData.email}
        onChange={(e) => handleChange("email", e.target.value)}
        placeholder="Email"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Use Cases

* **Page Identification**: Set descriptive titles for different pages and views
* **Dynamic Content**: Update titles based on loaded data or user actions
* **Notification System**: Show urgent information in the browser tab
* **Form Management**: Indicate form status or validation state
* **Real-time Updates**: Display live data like unread messages or timer counts
* **Modal Dialogs**: Temporarily change title when important dialogs are open
* **Navigation Context**: Show current location in multi-level navigation
* **Progress Tracking**: Display progress status for long-running operations


# useIdle
URL: /unlogg-hooks/utilities/use-idle

A custom React hook that detects if the user is idle by monitoring various DOM events.

`useIdle` is a custom React hook that detects when a user becomes idle by monitoring DOM events such as mouse movements, key presses, clicks, and scrolls. It's perfect for implementing features like auto-logout, hiding UI elements during inactivity, or triggering actions when users step away from their devices.

## Example

<ComponentPreview name="use-idle-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-idle" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-idle" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-idle" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Monitors multiple DOM events by default: keydown, click, scroll, wheel, mousemove, touchmove
* Timeout duration is required as the first parameter
* Configurable event list for specific use cases
* Automatically cleans up event listeners on unmount
* Client-side only (safe for SSR applications)
* Efficient event handling with proper throttling via timeout
* Initial state defaults to `true` (idle by default)

## API Reference

### Parameters

<TypeTable
  type={{
  timeout: {
    description: "The duration in milliseconds after which the user is considered idle if no events are detected.",
    type: "number",
    required: true,
  },
  options: {
    description: "Optional configuration object to override default idle detection options.",
    type: "UseIdleOptions",
    default: "undefined",
  },
}}
/>

### UseIdleOptions

<TypeTable
  type={{
  events: {
    description: "Array of DOM event names that reset the idle timer.",
    type: "(keyof DocumentEventMap)[]",
    default: "['keydown', 'click', 'scroll', 'wheel', 'mousemove', 'touchmove']",
  },
  initialState: {
    description: "Initial idle state.",
    type: "boolean",
    default: "true",
  },
}}
/>

### Returns

<TypeTable
  type={{
  isIdle: {
    description: "A boolean indicating whether the user is currently idle.",
    type: "boolean",
  },
}}
/>

## Usage

```tsx
import { useIdle } from "@/hooks/use-idle";

function IdleIndicator() {
  const isIdle = useIdle(5000); // User is idle after 5 seconds
  
  return (
    <div>
      Status: {isIdle ? 'User is idle' : 'User is active'}
    </div>
  );
}
```

## Advanced Usage

### Auto-Logout System

Implement automatic logout after a period of inactivity:

```tsx
function AutoLogout() {
  const isIdle = useIdle(30000); // 30 seconds
  const [showWarning, setShowWarning] = useState(false);
  
  useEffect(() => {
    if (isIdle) {
      setShowWarning(true);
      // Show warning for 10 seconds before logout
      const logoutTimer = setTimeout(() => {
        logout();
      }, 10000);
      
      return () => clearTimeout(logoutTimer);
    } else {
      setShowWarning(false);
    }
  }, [isIdle]);
  
  if (showWarning) {
    return (
      <div className="warning-modal">
        <h2>Session Warning</h2>
        <p>You will be logged out in 10 seconds due to inactivity.</p>
        <button onClick={() => setShowWarning(false)}>
          Stay Logged In
        </button>
      </div>
    );
  }
  
  return <div>Your session is active</div>;
}
```

### Custom Event Monitoring

Monitor only specific types of user activity:

```tsx
function MouseTracker() {
  // Only track mouse-related activity
  const isMouseIdle = useIdle(5000, {
    events: ['mousemove', 'click']
  });
  
  return (
    <div>
      Mouse status: {isMouseIdle ? 'Inactive' : 'Active'}
      <p>This only responds to mouse movement and clicks</p>
    </div>
  );
}

function KeyboardTracker() {
  // Only track keyboard activity
  const isKeyboardIdle = useIdle(3000, {
    events: ['keydown']
  });
  
  return (
    <div>
      Keyboard status: {isKeyboardIdle ? 'Inactive' : 'Active'}
      <p>Type something to reset the idle state</p>
    </div>
  );
}
```

### Auto-Save Functionality

Automatically save content when user stops typing:

```tsx
function AutoSaveEditor() {
  const [content, setContent] = useState('');
  const [savedContent, setSavedContent] = useState('');
  const [lastSaved, setLastSaved] = useState(null);
  
  // Detect when user stops typing (2 second delay)
  const isIdle = useIdle(2000, { 
    events: ['keydown'] // Only keyboard events
  });
  
  useEffect(() => {
    if (isIdle && content !== savedContent && content.trim()) {
      // Auto-save the content
      saveContent(content);
      setSavedContent(content);
      setLastSaved(new Date());
    }
  }, [isIdle, content, savedContent]);
  
  const saveContent = async (text) => {
    // Your save logic here
    console.log('Auto-saving:', text);
  };
  
  return (
    <div>
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Start typing... (auto-saves when you stop)"
      />
      {lastSaved && (
        <p>Last saved: {lastSaved.toLocaleTimeString()}</p>
      )}
    </div>
  );
}
```

### Screen Saver Mode

Hide sensitive content when user is away:

```tsx
function SensitiveContent() {
  const isIdle = useIdle(10000); // 10 seconds
  
  if (isIdle) {
    return (
      <div className="screen-saver">
        <h2>Screen Locked</h2>
        <p>Move your mouse or press any key to continue</p>
        <div className="loading-animation">🔒</div>
      </div>
    );
  }
  
  return (
    <div>
      <h1>Confidential Information</h1>
      <p>This sensitive content is hidden when you're away</p>
      {/* Your sensitive content here */}
    </div>
  );
}
```

### Multiple Idle Timers

Track different types of inactivity simultaneously:

```tsx
function MultipleIdleStates() {
  const quickIdle = useIdle(2000);   // 2 seconds
  const mediumIdle = useIdle(10000); // 10 seconds
  const longIdle = useIdle(60000);   // 1 minute
  
  return (
    <div>
      <div>Quick idle (2s): {quickIdle ? '💤' : '👀'}</div>
      <div>Medium idle (10s): {mediumIdle ? '😴' : '🙂'}</div>
      <div>Long idle (1m): {longIdle ? '🌙' : '☀️'}</div>
      
      {longIdle && (
        <div>Consider taking a break! You've been inactive for over a minute.</div>
      )}
    </div>
  );
}
```

### Gaming Pause Feature

Automatically pause games when player becomes inactive:

```tsx
function GameComponent() {
  const [gameState, setGameState] = useState('playing');
  const isIdle = useIdle(5000, { 
    events: ['keydown', 'click'] // Game-relevant events
  });
  
  useEffect(() => {
    if (isIdle && gameState === 'playing') {
      setGameState('paused');
      console.log('Game auto-paused due to inactivity');
    } else if (!isIdle && gameState === 'paused') {
      // Optional: Auto-resume or require manual resume
      // setGameState('playing');
    }
  }, [isIdle, gameState]);
  
  return (
    <div>
      <h2>Game Status: {gameState}</h2>
      {gameState === 'paused' && (
        <div>
          <p>Game paused due to inactivity</p>
          <button onClick={() => setGameState('playing')}>
            Resume Game
          </button>
        </div>
      )}
      {/* Game content */}
    </div>
  );
}
```

### Analytics and User Behavior

Track user engagement patterns:

```tsx
function EngagementTracker() {
  const [engagementData, setEngagementData] = useState({
    totalTime: 0,
    activeTime: 0,
    idleTime: 0
  });
  
  const isIdle = useIdle(3000);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setEngagementData(prev => ({
        totalTime: prev.totalTime + 1,
        activeTime: isIdle ? prev.activeTime : prev.activeTime + 1,
        idleTime: isIdle ? prev.idleTime + 1 : prev.idleTime
      }));
    }, 1000);
    
    return () => clearInterval(interval);
  }, [isIdle]);
  
  const engagementRate = (engagementData.activeTime / engagementData.totalTime * 100).toFixed(1);
  
  return (
    <div>
      <h3>User Engagement Analytics</h3>
      <div>Total Time: {engagementData.totalTime}s</div>
      <div>Active Time: {engagementData.activeTime}s</div>
      <div>Idle Time: {engagementData.idleTime}s</div>
      <div>Engagement Rate: {engagementRate}%</div>
    </div>
  );
}
```

## Use Cases

* **Auto-Logout**: Automatically log users out after periods of inactivity for security
* **Screen Savers**: Hide sensitive content when users step away
* **Auto-Save**: Save user work automatically when they stop typing or editing
* **Game Pausing**: Pause games when players become inactive
* **Power Management**: Reduce resource usage during idle periods
* **Analytics**: Track user engagement and activity patterns
* **Session Management**: Extend or warn about session timeouts
* **Content Protection**: Hide confidential information during inactivity


# useIsOnline
URL: /unlogg-hooks/utilities/use-is-online

Detect the users online status and network connection information.

`useIsOnline` is a custom React hook that detects when a user is online or offline and optionally provides detailed network connection information using the experimental Network Information API.

<Callout type="warning" title="Experimental API" className="mb-8">
  The Network Information API is experimental and may not be available in all browsers.
  See the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection#browser_compatibility" target="_blank" rel="noopener noreferrer">MDN documentation</a> for more details.
</Callout>

<ComponentPreview name="use-is-online-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-is-online" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-is-online" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-is-online" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## How to test

Try these methods to test offline/online detection:
Disconnect your WiFi or ethernet cable
Use browser developer tools to simulate offline mode
Switch between WiFi and cellular data (mobile)
Use airplane mode on mobile devices

## Notes

* Monitors `navigator.onLine` for basic online/offline detection
* Uses experimental `navigator.connection` API for detailed network information
* Automatically handles browser compatibility and logs warnings when APIs are unavailable
* Client-side only (safe for SSR applications)
* Useful for adaptive content loading, offline mode, and network-aware functionality

## API Reference

### Parameters

This hook takes no parameters.

### Returns

<TypeTable
  type={{
  isOnline: {
    description: "A boolean indicating whether the user is currently online.",
    type: "boolean",
  },
  networkInfo: {
    description: "An object containing detailed network connection information (undefined if not supported).",
    type: "NetworkInformation | undefined",
  },
}}
/>

### NetworkInformation

<TypeTable
  type={{
  downlink: {
    description: "The effective bandwidth estimate in megabits per second.",
    type: "number | undefined",
  },
  downlinkMax: {
    description: "The maximum downlink speed in megabits per second.",
    type: "number | undefined",
  },
  effectiveType: {
    description: "The effective connection type (slow-2g, 2g, 3g, 4g).",
    type: "'slow-2g' | '2g' | '3g' | '4g' | undefined",
  },
  rtt: {
    description: "The estimated round-trip time in milliseconds.",
    type: "number | undefined",
  },
  saveData: {
    description: "Whether the user has requested a reduced data usage mode.",
    type: "boolean | undefined",
  },
  type: {
    description: "The type of connection being used.",
    type: "'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown' | undefined",
  },
}}
/>

## Usage

```tsx
import { useIsOnline } from "@/hooks/use-is-online";

function NetworkStatus() {
  const { isOnline, networkInfo } = useIsOnline();
  
  return (
    <div>
      <p>Status: {isOnline ? "Online" : "Offline"}</p>
      {networkInfo && (
        <p>Connection: {networkInfo.effectiveType}</p>
      )}
    </div>
  );
}
```

## Examples

### Display network information

<ComponentPreview name="use-is-online-ex-02" classNameComponentContainer="min-h-[600px]" />

### Adaptive Content Loading

Load different content based on network conditions:

```tsx
function AdaptiveContent() {
  const { isOnline, networkInfo } = useIsOnline();
  
  const getImageQuality = () => {
    if (!isOnline) return 'cached';
    if (networkInfo?.saveData) return 'low';
    if (networkInfo?.effectiveType === 'slow-2g' || networkInfo?.effectiveType === '2g') {
      return 'compressed';
    }
    return 'high';
  };
  
  const imageQuality = getImageQuality();
  
  return (
    <div>
      {imageQuality === 'cached' && (
        <div>Showing cached content - you're offline</div>
      )}
      {imageQuality === 'low' && (
        <img src="image-low.webp" alt="Low quality for data saver" />
      )}
      {imageQuality === 'compressed' && (
        <img src="image-compressed.webp" alt="Compressed for slow connection" />
      )}
      {imageQuality === 'high' && (
        <img src="image-high.webp" alt="High quality image" />
      )}
    </div>
  );
}
```

### Offline Mode with Sync

Implement offline functionality with data synchronization:

```tsx
function OfflineApp() {
  const { isOnline } = useIsOnline();
  const [pendingActions, setPendingActions] = useState([]);
  const [cachedData, setCachedData] = useState([]);
  
  // Sync pending actions when back online
  useEffect(() => {
    if (isOnline && pendingActions.length > 0) {
      syncPendingActions(pendingActions);
      setPendingActions([]);
    }
  }, [isOnline, pendingActions]);
  
  const handleUserAction = (action) => {
    if (isOnline) {
      // Execute immediately
      executeAction(action);
    } else {
      // Queue for later sync
      setPendingActions(prev => [...prev, action]);
      // Update local cache
      updateLocalCache(action);
    }
  };
  
  return (
    <div>
      {!isOnline && (
        <div className="offline-banner">
          You're offline. Actions will sync when connection is restored.
          {pendingActions.length > 0 && (
            <span>({pendingActions.length} pending)</span>
          )}
        </div>
      )}
      
      <button onClick={() => handleUserAction('like')}>
        Like Post
      </button>
    </div>
  );
}
```

### Data Saver Mode

Respect user's data saving preferences:

```tsx
function DataAwareComponent() {
  const { networkInfo } = useIsOnline();
  const [autoplayEnabled, setAutoplayEnabled] = useState(true);
  
  useEffect(() => {
    if (networkInfo?.saveData) {
      setAutoplayEnabled(false);
      console.log('Data saver mode detected - disabling autoplay');
    }
  }, [networkInfo?.saveData]);
  
  return (
    <div>
      <video
        src="video.mp4"
        autoPlay={autoplayEnabled}
        controls
      />
      
      {networkInfo?.saveData && (
        <div className="data-saver-notice">
          📱 Data saver mode active - autoplay disabled
        </div>
      )}
    </div>
  );
}
```

### Network-Aware API Calls

Adjust API behavior based on connection quality:

```tsx
function NetworkAwareAPI() {
  const { isOnline, networkInfo } = useIsOnline();
  
  const fetchData = async () => {
    if (!isOnline) {
      return getCachedData();
    }
    
    const requestOptions = {
      // Base options
      timeout: 10000,
    };
    
    // Adjust based on connection quality
    if (networkInfo?.effectiveType === 'slow-2g' || networkInfo?.effectiveType === '2g') {
      requestOptions.timeout = 30000; // Longer timeout for slow connections
      return fetchCompressedData(requestOptions);
    }
    
    if (networkInfo?.saveData) {
      return fetchMinimalData(requestOptions);
    }
    
    return fetchFullData(requestOptions);
  };
  
  return (
    <div>
      <button onClick={fetchData}>
        Load Data
      </button>
      
      {networkInfo && (
        <div className="connection-info">
          Connection: {networkInfo.effectiveType} 
          ({networkInfo.downlink?.toFixed(1)} Mbps)
        </div>
      )}
    </div>
  );
}
```

## Use Cases

* **Offline Mode**: Provide functionality when users lose internet connection
* **Adaptive Loading**: Adjust content quality based on connection speed
* **Data Saver Support**: Respect user's data saving preferences
* **Progressive Enhancement**: Load content progressively based on network conditions
* **Smart Prefetching**: Intelligently prefetch content on good connections
* **Network Monitoring**: Track connection quality for analytics
* **Error Handling**: Provide better error messages for network issues
* **Performance Optimization**: Optimize API calls and resource loading


# useLeavePage
URL: /unlogg-hooks/utilities/use-leave-page

A custom React hook that detects when the user is leaving the page by monitoring the mouseleave event.

`useLeavePage` is a custom React hook that detects when a user is about to leave the page by monitoring when their mouse cursor leaves the browser window. This is commonly used for implementing exit-intent popups, auto-saving content, or showing retention messages to keep users engaged.

<ComponentPreview name="use-leave-page-ex-01" classNameComponentContainer="min-h-[600px]" />

## Install

<ComponentInstall name="use-leave-page" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="use-leave-page" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="use-leave-page" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Notes

* Monitors the "mouseleave" event on the document by default
* Detects when the cursor leaves the browser window area
* Automatically resets when the cursor returns to the page
* Client-side only (safe for SSR applications)
* Useful for exit-intent functionality and user retention

## API Reference

### Parameters

This hook takes no parameters.

### Returns

<TypeTable
  type={{
  isLeavingPage: {
    description: "A boolean indicating whether the user is currently leaving the page (cursor outside browser window).",
    type: "boolean",
  },
}}
/>

## Usage

```tsx
import { useLeavePage } from "@/hooks/use-leave-page";

function ExitIntentPopup() {
  const isLeavingPage = useLeavePage();
  
  if (isLeavingPage) {
    return (
      <div className="popup">
        <h2>Wait! Don't leave yet!</h2>
        <p>You have unsaved changes.</p>
      </div>
    );
  }
  
  return <div>Page content</div>;
}
```

## Examples

### Exit intent popup

<ComponentPreview name="use-leave-page-ex-02" classNameComponentContainer="min-h-[600px]" />

### Auto save content on leave

<ComponentPreview name="use-leave-page-ex-03" classNameComponentContainer="min-h-[600px]" />

## Use Cases

* **Exit Intent Popups**: Show special offers or newsletters when users are about to leave
* **Auto-Save Functionality**: Automatically save user content when they move away
* **Cart Abandonment Prevention**: Remind users about items in their shopping cart
* **Form Data Protection**: Warn users about unsaved form changes
* **Analytics Tracking**: Track user exit behavior for optimization
* **Retention Messages**: Show engaging content to keep users on the page
* **Session Management**: Trigger session-related actions before users leave
* **Content Protection**: Save drafts or warn about unsaved work


# CLI
URL: /unlogg-ui/cli

Use the CLI to add components, blocks and pages to your project.

<Callout>
  We rely on `shadcn` CLI to add components and blocks to your project.
</Callout>

The CLI provides an easy, interactive way to add components, blocks and pages to your project.
Installing components using the CLI ensures that you have the latest version of the component and its dependencies.

## `init` command

You can use the `init` command to initialize configuration and dependencies for a new project.

The `init` command installs dependencies, adds the `cn` util and configures CSS variables for the project.

<Tabs items={["pnpm", "npm", "bun"]}>
  ```bash tab="pnpm"
  pnpm dlx shadcn@latest init
  ```

  ```bash tab="npm"
  npx shadcn@latest init
  ```

  ```bash tab="bun"
  bun x --bun shadcn@latest init
  ```
</Tabs>

You will be asked a few questions to initialize the project.

## `add` command

You can use the `add` command to add components, blocks and pages to your project.

The `add` command installs dependencies, adds the component, block or page to your project and updates the configuration.

<Tabs items={["pnpm", "npm", "bun"]}>
  ```bash tab="pnpm"
  pnpm dlx shadcn@latest add https://unlogg.com/r/product-card-01-block.json
  ```

  ```bash tab="npm"
  npx shadcn@latest add https://unlogg.com/r/product-card-01-block.json
  ```

  ```bash tab="bun"
  bun x --bun shadcn@latest add https://unlogg.com/r/product-card-01-block.json
  ```
</Tabs>

You can use the same command to add shadcn/ui components.

To see a list of all available options, please refer to the [shadcn/ui documentation](https://ui.shadcn.com/docs/cli).

## Monorepo support

If you need to install the components in a monorepo, you can use the optional `-c` flag.
This will allow you to specify the path to the project where you want to install the component.

<Tabs items={["pnpm", "npm", "bun"]}>
  ```bash tab="pnpm"
  pnpm dlx shadcn@latest add https://unlogg.com/r/product-card-01-block.json -c ./apps/www
  ```

  ```bash tab="npm"
  npx shadcn@latest add https://unlogg.com/r/product-card-01-block.json -c ./apps/www
  ```

  ```bash tab="bun"
  bun x --bun shadcn@latest add https://unlogg.com/r/product-card-01-block.json -c ./apps/www
  ```
</Tabs>

Read more about monorepo support using the `shadcn` CLI in the [shadcn/ui documentation](https://ui.shadcn.com/docs/monorepo).


# Active Button
URL: /unlogg-ui/components/active-button

A button component with active functionality

A button component that can toggle its active state, providing visual feedback when pressed.

<ComponentPreview name="active-button-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="active-button" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="active-button" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="active-button" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>


# Combobox Add
URL: /unlogg-ui/components/combobox-add

A Combobox component with add functionality

This components allows you to add new items to a list while also selecting existing ones. It combines the functionality of a combobox with the ability to add new entries.

<ComponentPreview name="combobox-add-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="combobox-add" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="combobox-add" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="combobox-add" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Examples

### Basic Usage

<ComponentPreview name="combobox-add-ex-02" classNameComponentContainer="min-h-[400px]" />

### With descriptions

<ComponentPreview name="combobox-add-ex-03" classNameComponentContainer="min-h-[400px]" />


# Date Selector
URL: /unlogg-ui/components/date-selector

A date selector component with natural language parsing

Set due dates using natural language like *in 2 hours* or *tomorrow at 3pm*.
Alternatively, you can select from predefined time periods like *1 hour*, *1 day*, *7 days*, or *30 days*.

<ComponentPreview name="date-selector-ex-01" classNameComponentContainer="min-h-[400px]" />

## Install

<ComponentInstall name="date-selector" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="date-selector" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="date-selector" />

      <Step>
        Update the import paths to match your project setup
      </Step>

      <Step>
        Install the required dependency:

        ```bash
        npm install chrono-node
        ```
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Features

* **Natural Language Parsing**: Type dates in natural language like "in 2 hours", "tomorrow at 3pm", or "next Friday"
* **Preset Options**: Quick selection with predefined time periods (1 hour, 1 day, 7 days, 30 days)
* **Future Dates Only**: Automatically ensures all selected dates are in the future
* **Flexible Formatting**: Displays both absolute and relative time formats
* **Keyboard Navigation**: Full keyboard support for accessibility

## Usage

The Date Selector component uses [chrono-node](https://github.com/wanasit/chrono) for natural language date parsing, allowing users to input dates in various formats:

* **Relative times**: "in 30 minutes", "in 2 hours", "in 3 days"
* **Specific dates**: "tomorrow", "next Friday", "Monday"
* **Date with time**: "tomorrow at 9am", "Friday at 2:30pm"
* **Complex expressions**: "next week Monday", "2 weeks from now"

## Examples

### Show relative time only

<ComponentPreview name="date-selector-ex-02" classNameComponentContainer="min-h-[400px]" />


# Upvote Button
URL: /unlogg-ui/components/upvote-button

A button component with upvote functionality

A button component that allows users to upvote content, providing visual feedback on the number of upvotes received.

<ComponentPreview name="upvote-button-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="upvote-button" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="upvote-button" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="upvote-button" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Features

* **Upvote Count**: Displays the number of upvotes.
* **Upvote State**: Changes appearance when the content is upvoted.
* **Customizable**: Easily integrate into your project with customizable styles.


# User Selector
URL: /unlogg-ui/components/user-selector

A user selector component with search and actions

This component allows you to select users from a list with search functionality. It also supports actions like adding new users and avatar placeholder generation.

<ComponentPreview name="user-selector-ex-01" classNameComponentContainer="min-h-[200px]" />

## Install

<ComponentInstall name="user-selector" classNameComponentContainer="min-h-[200px]">
  <CLIInstall name="user-selector" />

  <ManualInstall>
    <Steps>
      <Step>
        Copy and paste the following code into your project
      </Step>

      <ComponentSource name="user-selector" />

      <Step>
        Update the import paths to match your project setup
      </Step>
    </Steps>
  </ManualInstall>
</ComponentInstall>

## Examples

<ComponentPreview name="user-selector-ex-02" classNameComponentContainer="min-h-[200px]" />


# Overview
URL: /unlogg-ui

Build dashboard and web apps faster than ever

## What is unlogg/ui?

**unlogg/ui** is a collection of reusable components and design patterns for building dashboard and web apps. It’s a great way to speed up your design process and create a consistent look and feel across your site.

## How are the components built?

All the components and block are built with `React` and styled with `Tailwind CSS`. This makes it easy to customize the look and feel of the components to match your brand.

Some of the components and blocks also implement `shadcn/ui` components and design patterns (e.g.: global styles, typography, spacing, etc).

## Can I customize the components?

YES! You can customize the components however you like!

Since this is a "copy-paste" library, you can easily copy the components' code and paste it into your project (or install via the CLI). You can then modify the code to fit your needs, or use the components as a starting point for building your own.

## Project structures

The library is made of `components` and `blocks`.

### Components

Components are small, self-contained pieces of UI that can be used in multiple places across your site. They’re designed to be flexible and easy to customize. You can use `components` to build larger `blocks` or use them on their own.

### Blocks

Blocks are larger pieces of UI that are normally made up of multiple components. They’re designed to be used in specific contexts, like a product page or a checkout flow. You can use `blocks` to build entire pages or sections of your site.

## License

**unlogg/ui** is licensed under the MIT License. You are free to use it in personal and commercial projects. If you find it useful, please consider giving back by contributing to the project or spreading the word.

For more info see the [LICENSE](https://github.com/unlogg/blob/main/LICENSE) file.

## FAQ

<Accordions>
  <Accordion title="Can I use this in my project?">
    Definitely! **unlogg/ui** is free for personal and commercial projects.
    For more info see the [LICENSE](https://github.com/unlogg/blob/main/LICENSE) file.
  </Accordion>

  <Accordion title="Is this project ready to use?">
    Almost! We’re constantly adding new components and improving existing ones.
    You can of course use what’s here now, but be aware that things might change a little bit.
  </Accordion>

  <Accordion title="Can I contribute?">
    Yes, we'd love your help! You can open an issue or submit a pull request on our GitHub repository.

    Check [CONTRIBUTING.md](https://github.com/unlogg/blob/main/CONTRIBUTING.md) for more information on how to contribute.
  </Accordion>
</Accordions>


# Installation
URL: /unlogg-ui/installation

A simple guide to set up unlogg/ui with the required dependencies and structure.

This project is built with **Next.js**, using **TypeScript** and **Tailwind CSS** for all components.

##

<Steps>
  <Step>
    ### Install Tailwind CSS

    The components are styled using **Tailwind CSS v.4**.

    Follow the official [installation guide](https://tailwindcss.com/docs/installation) to set it up in your project. If you are still using Tailwind CSS v.3, you can follow the [Tailwindcss v.4 migration guide](https://tailwindcss.com/docs/upgrade-guide).
  </Step>

  <Step>
    ### Install `lucide-react` icons

    For the components that use icons, we use **Lucide React** icons.

    <Tabs items={['npm', 'pnpm', 'bun']}>
      ```bash tab="npm"
      npm install lucide-react
      ```

      ```bash tab="pnpm"
      pnpm add lucide-react
      ```

      ```bash tab="bun"
      bun add lucide-react
      ```
    </Tabs>
  </Step>

  <Step>
    ### Add a Utility Helper

    To make it easier to conditionally apply Tailwind CSS classes, add this `cn` helper function to your project.

    ```ts title="lib/utils.ts"
    import { clsx, type ClassValue } from 'clsx'
    import { twMerge } from 'tailwind-merge'

    export function cn(...inputs: ClassValue[]) {
      return twMerge(clsx(inputs))
    }
    ```

    You might need to install the `clsx` and `tailwind-merge` packages.

    <Tabs items={['npm', 'pnpm', 'bun']}>
      ```bash tab="npm"
      npm install clsx tailwind-merge
      ```

      ```bash tab="pnpm"
      pnpm add clsx tailwind-merge
      ```

      ```bash tab="bun"
      bun add clsx tailwind-merge
      ```
    </Tabs>
  </Step>

  <Step>
    ### Add your first component

    Now that you have set up the required dependencies, you can start adding components to your project.

    For example, to add the `StarRating` component, you can just:

    <Tabs items={['pnpm', 'npm','bun']}>
      ```bash tab="pnpm"
      pnpm shadcn@latest add https://unlogg.com/r/star-rating-basic-ex-01.json
      ```

      ```bash tab="npm"
      npx shadcn@latest add https://unlogg.com/r/star-rating-basic-ex-01.json
      ```

      ```bash tab="bun"
      bun shadcn@latest add https://unlogg.com/r/star-rating-basic-ex-01.json
      ```
    </Tabs>

    And then import the component in your project like:

    ```ts title="layouts/review.tsx"
    "use client";

    import StarRatingBasic from "@/components/unlogg-ui/test";
    import { useState } from "react";

    export default function Rating() {
      const [rating, setRating] = useState(3);
      return (
        <div className="flex flex-row items-center gap-4">
          <StarRatingBasic value={rating} onChange={setRating} maxStars={5} />
          <p>({rating})</p>
           {/* Rest of your code... */}
        </div>
      );
    }
    ```

    <Step>
      ## Done! 🎉

      You can now manually *copy-paste* the components or use the [CLI](/docs/cli) to add components, blocks, and pages to your project.

      Some components also rely on other third-party libraries like [shadcn/ui](https://ui.shadcn.com/docs/installation) and [Motion](https://motion.dev). These dependencies are specified in the component documentation.

      <Callout title="We recommend using the CLI">
        If you are using the CLI to add components, you don't need to worry about the dependencies. The CLI will take care of installing them for you. See the [CLI documentation](/docs/cli) for more information.
      </Callout>
    </Step>
  </Step>
</Steps>
